name: Create Aerospike Backup Tools Pre Release

permissions:
  contents: write
  packages: write
  id-token: write

on:
  workflow_dispatch:
  push:
    tags:
      - 'v*'

jobs:
  goreleaser:
    runs-on: ubuntu-24.04
    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 1
      - name: Set up Go
        uses: actions/setup-go@d35c59abb061a4a6fb18e82ac0862c26744d6ab5 # v5.5.0
        with:
          go-version: '1.23.x'

      - name: Import GPG key
        id: import-gpg
        uses: crazy-max/ghaction-import-gpg@e89d40939c28e39f97cf32126055eeae86ba74ec # v6.3.0
        with:
          gpg_private_key: ${{ secrets.GPG_SECRET_KEY }}
          passphrase: ${{ secrets.GPG_PASS }}

      - name: Run GoReleaser
        uses: goreleaser/goreleaser-action@9c156ee8a17a598857849441385a2041ef570552 # v6.3.0
        with:
          distribution: goreleaser
          version: "~> v2"
          args: release --clean
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GPG_FINGERPRINT: ${{ steps.import-gpg.outputs.fingerprint }}

  create-release:
    permissions:
      contents: write
    runs-on: ubuntu-24.04
    steps:
      - name: Check if release exists
        id: check-release
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          script: |
            const tag = process.env.GITHUB_REF_NAME;
            core.info(`Checking if release exists for tag: ${tag}`);
            try {
              const release = await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: tag
              });
              core.setOutput('release-exists', 'true');
              core.notice("Release already exists.");
            } catch (error) {
              if (error.status === 404) {
                core.setOutput('release-exists', 'false');
                core.notice("Release not found. Will create a new one.");
              } else {
                core.setFailed(`Unexpected error while checking release: ${error.message}`);
                throw error;
              }
            }

      - name: Create new release if it does not exist
        if: ${{ steps.check-release.outputs.release-exists == 'false' }}
        id: create-release
        uses: ncipollo/release-action@bcfe5470707e8832e12347755757cec0eb3c22af # v1.18.0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag: ${{ github.ref_name }}
          draft: true
          prerelease: true

  build-packages:
    permissions:
      contents: write
    needs:
      - create-release
    runs-on: ubuntu-22.04
    outputs:
      package_version: ${{ steps.metadata.outputs.PACKAGE_VERSION }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 1
          ref: ${{ github.ref }}

      - name: Set up Go
        uses: actions/setup-go@d35c59abb061a4a6fb18e82ac0862c26744d6ab5 # v5.5.0
        with:
          go-version: '1.23.x'

      - name: setup GPG
        uses: aerospike/shared-workflows/.github/actions/setup-gpg@dda8173aca1f1e73f95267572a7d3849cd00f1b8 # v1.0.0
        with:
          gpg-private-key: ${{ secrets.GPG_SECRET_KEY }}
          gpg-public-key: ${{ secrets.GPG_PUBLIC_KEY }}
          gpg-key-pass: ${{ secrets.GPG_PASS }}

      - name: Install Dependencies
        run: |
          echo "Installing nfpm..."
          go install "github.com/goreleaser/nfpm/v2/cmd/nfpm@latest"
          if [ $? -eq 0 ]; then
            echo "nfpm installed successfully."
          else
            echo "Failed to install nfpm." >&2
            exit 1
          fi
          
          echo "Updating apt repositories..."
          sudo apt-get update
          if [ $? -eq 0 ]; then
            echo "apt update completed."
          else
            echo "apt update failed." >&2
            exit 1
          fi
          
          echo "Installing dpkg-dev and dpkg-sig..."
          sudo apt-get install -y dpkg-dev dpkg-sig
          if [ $? -eq 0 ]; then
            echo "dpkg-dev and dpkg-sig installed."
          else
            echo "Failed to install dpkg dependencies." >&2
            exit 1
          fi

      - name: Get Metadata
        id: metadata
        run: |
          echo "Starting metadata extraction..."
          
          if [ ! -f VERSION ]; then
            echo "VERSION file not found. Exiting." >&2
            exit 1
          fi
          
          PACKAGE_VERSION=$(cat VERSION)
          PACKAGE_NAME="${GITHUB_REPOSITORY##*/}"
          
          echo "Read VERSION: $PACKAGE_VERSION"
          echo "Determined package name: $PACKAGE_NAME"
          
          echo "PACKAGE_VERSION=$PACKAGE_VERSION" >> $GITHUB_ENV
          echo "PACKAGE_VERSION=$PACKAGE_VERSION" >> $GITHUB_OUTPUT
          echo "PACKAGE_NAME=$PACKAGE_NAME" >> $GITHUB_ENV
          
          echo "Metadata extraction completed successfully."

      - name: Login to JFrog
        uses: jfrog/setup-jfrog-cli@ff5cb544114ffc152db9cea1cd3d5978d5074946 #v4.5.11
        env:
          JF_URL: ${{ vars.ARTIFACTORY_URL }}
          JF_ACCESS_TOKEN: ${{ secrets.ARTIFACTORY_TOKEN }}
          JF_PROJECT: ${{ vars.JFROG_CLI_BUILD_PROJECT }}

      - name: Build Packages
        run: |
          echo "Starting package build using 'make packages'..."
          
          if [ ! -f Makefile ]; then
            echo "Makefile not found. Cannot run 'make packages'." >&2
            exit 1
          fi
          
          make packages
          BUILD_RESULT=$?
          
          if [ $BUILD_RESULT -eq 0 ]; then
            echo "Package build completed successfully."
          else
            echo "Package build failed with exit code $BUILD_RESULT." >&2
            exit $BUILD_RESULT
          fi

      - name: Find files matching "*.rpm" "*.deb"
        run: |
          echo "Searching for .rpm and .deb package files..."
          
          RPM_ASSET_LIST=$(find . -type f \( -name "*.rpm" \) | tr '\n' ',')
          DEB_ASSET_LIST=$(find . -type f \( -name "*.deb" \) | tr '\n' ',')
          
          echo "RPM files found:"
          echo "$RPM_ASSET_LIST" | tr ',' '\n'
          
          echo "DEB files found:"
          echo "$DEB_ASSET_LIST" | tr ',' '\n'
          
          echo "RPM_ASSET_LIST=$RPM_ASSET_LIST" >> $GITHUB_ENV
          echo "DEB_ASSET_LIST=$DEB_ASSET_LIST" >> $GITHUB_ENV
          
          if [ -z "$RPM_ASSET_LIST" ] && [ -z "$DEB_ASSET_LIST" ]; then
            echo "No .rpm or .deb files found." >&2
          else
            echo "File discovery completed."
          fi

      - name: Sign RPM Packages
        env:
          GPG_TTY: no-tty
        run: |
          echo "Starting GPG signing process for RPM packages..."
          
          if [ -z "$RPM_ASSET_LIST" ]; then
            echo "RPM_ASSET_LIST is empty. No RPM packages to sign." >&2
            exit 1
          fi
          
          IFS=',' read -r -a asset_array <<< "$RPM_ASSET_LIST"
          for file in "${asset_array[@]}"; do
            if [ -z "$file" ]; then
              continue
            fi
          
            echo "Signing file: ${file}"
            rpm --addsign "${file}"
            if [ $? -ne 0 ]; then
              echo "Failed to sign ${file} with rpm --addsign." >&2
              exit 1
            fi
          
            OUTPUT=$(rpm --checksig "${file}")
            echo "Signature check output: $OUTPUT"
          
            if [[ "$OUTPUT" =~ 'digests signatures OK' ]]; then
              echo "Successfully GPG Signed: $file"
            else
              echo "GPG Signing failed verification for: $file" >&2
              exit 1
            fi
          done
          
          echo "All RPM packages signed and verified successfully."


      - name: Sign DEB Packages
        env:
          GPG_TTY: no-tty
        run: |
          echo "Starting GPG signing process for DEB packages..."
          
          if [ -z "$DEB_ASSET_LIST" ]; then
            echo "DEB_ASSET_LIST is empty. No DEB packages to sign." >&2
            exit 1
          fi
          
          IFS=',' read -r -a asset_array <<< "$DEB_ASSET_LIST"
          for file in "${asset_array[@]}"; do
            if [ -z "$file" ]; then
              continue
            fi
          
            echo "Signing file: ${file}"
            dpkg-sig --sign builder "${file}"
            if [ $? -ne 0 ]; then
              echo "Failed to sign ${file} with dpkg-sig." >&2
              exit 1
            fi
          
            OUTPUT=$(dpkg-sig --verify "${file}")
            echo "Signature check output for ${file}:"
            echo "$OUTPUT"
          
            if [[ "$OUTPUT" =~ 'GOODSIG _gpgbuilder' ]]; then
              echo "Successfully GPG Signed: $file"
            else
              echo "GPG Signing failed verification for: $file" >&2
              exit 1
            fi
          done
          
          echo "All DEB packages signed and verified successfully."

      - name: Create checksums
        run: |
          echo "Starting checksum generation with 'make checksums'..."
          
          make checksums
          if [ $? -ne 0 ]; then
            echo "Checksum generation failed during 'make checksums'." >&2
            exit 1
          fi
          
          echo "Searching for .sha256 files..."
          CHECKSUMS_ASSET_LIST=$(find . -type f \( -name "*.sha256" \) | tr '\n' ',')
          
          if [ -z "$CHECKSUMS_ASSET_LIST" ]; then
            echo "No .sha256 checksum files found." >&2
            exit 1
          else
            echo "Found checksum files:"
            echo "$CHECKSUMS_ASSET_LIST" | tr ',' '\n'
          fi
          
          echo "CHECKSUMS_ASSET_LIST=$CHECKSUMS_ASSET_LIST" >> $GITHUB_ENV
          
          echo "Checksum creation and discovery completed."

      - name: Sign checksums
        env:
          GPG_TTY: no-tty
          GPG_PASSPHRASE: ${{ secrets.GPG_PASS }}
        run: |
          echo "Starting GPG signing process for checksum files."
          
          if [ -z "$CHECKSUMS_ASSET_LIST" ]; then
            echo "CHECKSUMS_ASSET_LIST is empty. No checksum files to sign."
            exit 1
          fi
          
          IFS=',' read -r -a asset_array <<< "$CHECKSUMS_ASSET_LIST"
          for file in "${asset_array[@]}"; do
            if [ -z "$file" ]; then
              continue
            fi
          
            echo "Signing file: ${file}"
            gpg --detach-sign --no-tty --batch --yes --output "${file}.asc" --passphrase "$GPG_PASSPHRASE" "${file}"
            if [ $? -ne 0 ]; then
              echo "Failed to sign ${file}"
              exit 1
            fi
          
            gpg --verify "${file}.asc" "${file}" &>/dev/null
            RETURN_CODE=$?
            if [ "$RETURN_CODE" -ne 0 ]; then
              echo "Signature verification failed for ${file}"
              exit 1
            else
              echo "Successfully signed and verified ${file}"
            fi
          done
          
          echo "Searching for .asc signature files..."
          ASC_ASSET_LIST=$(find . -type f \( -name "*.asc" \) | tr '\n' ',')
          if [ -z "$ASC_ASSET_LIST" ]; then
            echo "No .asc files found after signing."
            exit 1
          fi
          
          echo "Found the following signature files:"
          echo "$ASC_ASSET_LIST" | tr ',' '\n'
          
          echo "ASC_ASSET_LIST=$ASC_ASSET_LIST" >> $GITHUB_ENV
          echo "Checksum signing process completed successfully."

      - name: Upload Assets to GitHub Release
        uses: softprops/action-gh-release@72f2c25fcb47643c292f7107632f7a47c1df5cd8 # v2.3.2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          tag_name: ${{ github.ref_name }}
          files: |
            **/*.rpm 
            **/*.deb 
            **/*.sha256 
            **/*.asc

      - name: Upload RPM Packages to Jfrog
        env:
          JF_PROJECT: ${{ vars.JFROG_CLI_BUILD_PROJECT }}
          ARTIFACTORY_RPM_DEV: ${{ vars.ARTIFACTORY_RPM_DEV }}
        run: |
          echo "Starting upload of RPM packages to JFrog."
          
          if [ -z "$RPM_ASSET_LIST" ]; then
            echo "RPM_ASSET_LIST is empty. No RPM packages to upload."
            exit 1
          fi
          
          IFS=',' read -r -a asset_array <<< "$RPM_ASSET_LIST"
          for file in "${asset_array[@]}"; do
            if [ -z "$file" ] || [ ! -f "$file" ]; then
              echo "File not found or empty entry: $file"
              exit 1
            fi
          
            arch=$(rpm -q --qf "%{ARCH}" -p "$file")
            target_path="$ARTIFACTORY_RPM_DEV/$PACKAGE_NAME/$PACKAGE_VERSION/$(basename $file)"
          
            echo "Uploading RPM: $file"
            echo "Target path: $target_path"
            echo "Architecture: $arch"
          
            jfrog rt upload "$file" "$target_path" \
              --build-name=$PACKAGE_NAME-rpm \
              --build-number=$PACKAGE_VERSION \
              --target-props "rpm.distribution=stable;rpm.component=main;rpm.architecture=$arch"
          
            if [ $? -ne 0 ]; then
              echo "Failed to upload $file to JFrog."
              exit 1
            else
              echo "Successfully uploaded $file to JFrog."
            fi
          done
          
          echo "Collecting environment variables for build info."
          jfrog rt build-collect-env "$PACKAGE_NAME-rpm" "$PACKAGE_VERSION"
          
          echo "Adding Git metadata to build info."
          jfrog rt build-add-git "$PACKAGE_NAME-rpm" "$PACKAGE_VERSION"
          
          echo "Publishing RPM build info to JFrog."
          jfrog rt build-publish "$PACKAGE_NAME-rpm" "$PACKAGE_VERSION"
          
          echo "RPM package upload and build info publication completed."

      - name: Upload DEB Packages to Jfrog
        env:
          JF_PROJECT: ${{ vars.JFROG_CLI_BUILD_PROJECT }}
          ARTIFACTORY_DEB_DEV: ${{ vars.ARTIFACTORY_DEB_DEV }}
        run: |
          echo "Starting upload of DEB packages to JFrog."
          
          if [ -z "$DEB_ASSET_LIST" ]; then
            echo "DEB_ASSET_LIST is empty. No DEB packages to upload."
            exit 1
          fi
          
          IFS=',' read -r -a asset_array <<< "$DEB_ASSET_LIST"
          for file in "${asset_array[@]}"; do
            if [ -z "$file" ] || [ ! -f "$file" ]; then
              echo "File not found or empty entry: $file"
              exit 1
            fi
          
            arch=$(dpkg --info "$file" | grep 'Architecture' | awk '{print $2}')
            target_path="$ARTIFACTORY_DEB_DEV/$PACKAGE_NAME/$PACKAGE_VERSION/$(basename $file)"
          
            echo "Uploading DEB: $file"
            echo "Target path: $target_path"
            echo "Architecture: $arch"
          
            jfrog rt upload "$file" "$target_path" \
              --build-name=$PACKAGE_NAME-deb \
              --build-number=$PACKAGE_VERSION \
              --target-props "deb.distribution=stable;deb.component=main;deb.architecture=${arch}" \
              --deb "stable/main/${arch}"
          
            if [ $? -ne 0 ]; then
              echo "Failed to upload $file to JFrog."
              exit 1
            else
              echo "Successfully uploaded $file to JFrog."
            fi
          done
          
          echo "Collecting environment variables for DEB build info."
          jfrog rt build-collect-env "$PACKAGE_NAME-deb" "$PACKAGE_VERSION"
          
          echo "Adding Git metadata to DEB build info."
          jfrog rt build-add-git "$PACKAGE_NAME-deb" "$PACKAGE_VERSION"
          
          echo "Publishing DEB build info to JFrog."
          jfrog rt build-publish "$PACKAGE_NAME-deb" "$PACKAGE_VERSION"
          
          echo "DEB package upload and build info publication completed."

  build-docker-image:
    needs:
      - create-release
    runs-on: ubuntu-24.04
    outputs:
      image_version: ${{ steps.metadata.outputs.IMAGE_VERSION }}
    steps:
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435 # v3.11.1
      - name: Checkout Code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 1
          ref: ${{ github.ref }}

      - name: Get Metadata
        env:
          GIT_TAG: ${{ github.ref }}
        id: metadata
        run: |
          echo "Starting metadata extraction for Docker image build."
                    
          if [ ! -f go.mod ]; then
            echo "go.mod file not found. Cannot determine Go version."
            exit 1
          fi
          
          echo "Setting Metadata variables"
          IMAGE_VERSION=$(cat $GIT_TAG | cut -c 2-)
          RAW_VERSION=$GIT_TAG
          
          echo "Determining appropriate Go version based on go.mod."
          GO_VERSION="$(curl -s 'https://go.dev/dl/?mode=json' | \
            jq -r --arg ver "go$(grep '^go ' go.mod | cut -d ' ' -f2 | cut -d. -f1,2)" \
              '.[] | select(.version | startswith($ver)) | .version' | \
            sort -V | \
            tail -n1 | \
            cut -c3- | \
            tr -d '\n')"
          
          if [ -z "$GO_VERSION" ]; then
            echo "Failed to resolve Go version."
            exit 1
          fi
          
          ISO8601=$(LC_TIME=en_US.UTF-8 date "+%Y-%m-%dT%H:%M:%S%z")
          IMAGE_NAME="${GITHUB_REPOSITORY##*/}"
          
          echo "Resolved metadata values:"
          echo "  VERSION: $RAW_VERSION"
          echo "  IMAGE_VERSION: $IMAGE_VERSION"
          echo "  GO_VERSION: $GO_VERSION"
          echo "  ISO8601: $ISO8601"
          echo "  IMAGE_NAME: $IMAGE_NAME"
          
          echo "IMAGE_VERSION=$IMAGE_VERSION" >> $GITHUB_ENV
          echo "IMAGE_VERSION=$IMAGE_VERSION" >> $GITHUB_OUTPUT
          echo "GO_VERSION=$GO_VERSION" >> "$GITHUB_ENV"
          echo "VERSION=$RAW_VERSION" >> $GITHUB_ENV
          echo "ISO8601=$ISO8601" >> $GITHUB_ENV
          echo "IMAGE_NAME=$IMAGE_NAME" >> $GITHUB_ENV
          
          echo "Metadata extraction completed."

      - name: Login to JFrog
        uses: jfrog/setup-jfrog-cli@ff5cb544114ffc152db9cea1cd3d5978d5074946 # v4.5.11
        env:
          JF_URL: ${{ vars.ARTIFACTORY_URL }}
          JF_ACCESS_TOKEN: ${{ secrets.ARTIFACTORY_TOKEN }}
          JF_PROJECT: ${{ vars.JFROG_CLI_BUILD_PROJECT }}

      - name: Login to JFrog Artifactory
        uses: docker/login-action@74a5d142397b4f367a81961eba4e8cd7edddf772 # v3.4.0
        with:
          registry: ${{ vars.ARTIFACTORY_REGISTRY_URL }}
          username: ${{ secrets.ARTIFACTORY_USER }}
          password: ${{ secrets.ARTIFACTORY_TOKEN }}

      - name: Build and Push Docker Image
        env:
          CONTEXT: ${{ github.workspace }}
          LATEST: false
          TAG: ${{env.IMAGE_VERSION}}
          GIT_BRANCH: ${{ github.ref }}
          GIT_COMMIT_SHA: ${{ github.sha }}
          VERSION: ${{env.VERSION}}
          ISO8601: ${{env.ISO8601}}
          IMAGE_NAME: ${{env.IMAGE_NAME}}
          GO_VERSION: ${{env.GO_VERSION}}
          OUTPUT: "type=image,push=true type=oci,dest=./cli-image.tar"
          REPO: ${{ vars.ARTIFACTORY_REGISTRY_URL }}/${{ vars.ARTIFACTORY_CONTAINER_DEV }}
          ARTIFACTORY_CONTAINER_DEV: ${{ vars.ARTIFACTORY_CONTAINER_DEV }}
        run: |
          echo "Starting Docker image build and push process."
          echo "Image Name: $IMAGE_NAME"
          echo "Image Tag: $TAG"
          echo "Go Version: $GO_VERSION"
          echo "Git Commit SHA: $GIT_COMMIT_SHA"
          echo "Git Branch: $GIT_BRANCH"
          echo "Context Directory: $CONTEXT"
          
          echo "Building Docker image with buildx bake."
          jfrog docker buildx bake \
            --file ${{ github.workspace }}/build/docker-build/docker-bake.hcl \
            --metadata-file=build-metadata \
            --progress plain \
            --no-cache \
            --push
          
          if [ $? -ne 0 ]; then
            echo "Docker image build failed."
            exit 1
          fi
          
          echo "Parsing build metadata to extract image digest."
          jq -r '
            .[] |
            {
              digest: .["containerimage.digest"],
              names: (.["image.name"] | split(","))
            } |
            .digest
          ' build-metadata > sha
          
          if [ ! -s sha ]; then
            echo "Failed to extract image digest. File 'sha' is empty or missing."
            exit 1
          fi
          
          FULL_IMAGE_REFERENCE="$ARTIFACTORY_REGISTRY_URL/$ARTIFACTORY_CONTAINER_DEV/$IMAGE_NAME:$TAG@$(cat sha)"
          echo "Resolved full image reference:"
          echo "$FULL_IMAGE_REFERENCE"
          echo "$FULL_IMAGE_REFERENCE" > meta-info
          
          echo "Creating Docker build info in JFrog."
          jfrog rt build-docker-create \
            --build-name=$IMAGE_NAME-container \
            --build-number=$TAG \
            --image-file ./meta-info \
            $ARTIFACTORY_CONTAINER_DEV
          
          echo "Collecting environment data for Docker build."
          jfrog rt build-collect-env $IMAGE_NAME-container $TAG
          
          echo "Adding Git metadata to Docker build info."
          jfrog rt build-add-git $IMAGE_NAME-container $TAG
          
          echo "Publishing Docker build info to JFrog."
          jfrog rt build-publish --detailed-summary $IMAGE_NAME-container $TAG
          
          echo "Docker image build and publication completed."

      - name: Upload tarball to GitHub Artifacts
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: cli-image
          path: ./cli-image.tar
          retention-days: 2
          overwrite: true

  create-release-bundle:
    needs:
      - create-release
      - build-packages
      - build-docker-image
    runs-on: ubuntu-24.04
    steps:
      - name: Login to JFrog
        uses: jfrog/setup-jfrog-cli@ff5cb544114ffc152db9cea1cd3d5978d5074946 # v4.5.11
        env:
          JF_URL: ${{ vars.ARTIFACTORY_URL }}
          JF_ACCESS_TOKEN: ${{ secrets.ARTIFACTORY_TOKEN }}
          JF_PROJECT: ${{ vars.JFROG_CLI_BUILD_PROJECT }}

      - name: Get Metadata
        run: |
          echo "Starting metadata extraction for release bundle."
          
          BUNDLE_NAME="${GITHUB_REPOSITORY##*/}"
          
          if [ -z "$BUNDLE_NAME" ]; then
            echo "Failed to determine BUNDLE_NAME from GITHUB_REPOSITORY."
            exit 1
          fi
          
          echo "BUNDLE_NAME resolved as: $BUNDLE_NAME"
          echo "BUNDLE_NAME=$BUNDLE_NAME" >> $GITHUB_ENV
          
          echo "Metadata extraction for release bundle completed."

      - name: Create release bundle
        env:
          BUNDLE_NAME: ${{ env.BUNDLE_NAME }}
          BUNDLE_VERSION: ${{ needs.build-packages.outputs.package_version }}
          PACKAGE_VERSION: ${{ needs.build-packages.outputs.package_version }}
          IMAGE_VERSION: ${{ needs.build-docker-image.outputs.image_version }}
          JF_PROJECT: ${{ vars.JFROG_CLI_BUILD_PROJECT }}
        run: |
          echo "Preparing release bundle specification."
          echo "Bundle Name: $BUNDLE_NAME"
          echo "Bundle Version: $BUNDLE_VERSION"
          echo "Package Version: $PACKAGE_VERSION"
          echo "Helm Chart Version: $HELM_VERSION"
          echo "Docker Image Version: $IMAGE_VERSION"
          echo "JFrog Project: $JF_PROJECT"
          
          cat <<EOF > release-bundle-spec.json
          {
            "name": "$BUNDLE_NAME",
            "version": "$BUNDLE_VERSION",
            "files": [
              {
                "project": "$JF_PROJECT",
                "build": "$BUNDLE_NAME-container/$IMAGE_VERSION"
              },
              {
                "project": "$JF_PROJECT",
                "build": "$BUNDLE_NAME-rpm/$PACKAGE_VERSION"
              },
              {
                "project": "$JF_PROJECT",
                "build": "$BUNDLE_NAME-deb/$PACKAGE_VERSION"
              }
            ]
          }
          EOF
          
          echo "Generated release bundle specification:"
          cat release-bundle-spec.json
          
          echo "Creating release bundle in JFrog..."
          jfrog release-bundle-create "$BUNDLE_NAME" "$BUNDLE_VERSION" \
          --spec release-bundle-spec.json \
          --project="$JF_PROJECT" \
          --signing-key="aerospike"
          
          if [ $? -ne 0 ]; then
          echo "Release bundle creation failed."
          exit 1
          fi
          
          echo "Release bundle created successfully."